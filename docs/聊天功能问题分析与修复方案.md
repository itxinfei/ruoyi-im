# IM聊天功能问题分析与修复方案

> 分析日期: 2026-01-09
> 项目: RuoYi-IM 企业级即时通讯系统

---

## 一、问题概述

经过深入分析前后端代码，发现聊天功能主要存在以下几类问题：

1. **API路径和数据结构不统一**
2. **变量命名混乱（sessionId vs conversationId）**
3. **WebSocket消息格式不一致**
4. **业务逻辑不完整**

---

## 二、详细问题清单

### 2.1 变量命名混乱问题

#### 问题描述
前端使用 `sessionId` 表示会话ID，后端使用 `conversationId`，导致概念混淆。

#### 具体表现

| 位置 | 变量名 | 说明 |
|------|--------|------|
| 前端Store (`im.js`) | `sessionId` | 表示会话ID |
| 前端API (`message.js`) | `conversationId` | API参数名 |
| 后端Controller | `conversationId` | 统一使用conversationId |
| 数据库表 | `conversation_id` | 数据库字段名 |

#### 代码位置
```javascript
// 前端 store/modules/im.js 第329行
async loadMessages({ commit }, { sessionId, page = 1, pageSize = 20 }) {
  const response = await listMessage({ conversationId: sessionId, page, pageSize })
  //                                   ^^^^^^^^^^^^^^ 映射
  ...
}

// 前端 store/modules/im.js 第345行
async sendMessage({ commit }, { sessionId, type, content, replyTo }) {
  ...
  const response = await apiSendMessage({
    conversationId: sessionId, // 映射
    ...
  })
}
```

#### 建议修复
**方案1**: 统一前端使用 `conversationId`（推荐）
**方案2**: 后端同时支持 `sessionId` 和 `conversationId` 参数

---

### 2.2 WebSocket消息格式不匹配 ⚠️ 关键问题

#### 问题描述
后端WebSocket处理时期望 `sessionId` 字段，但API使用 `conversationId`。

#### 后端期望格式（ImWebSocketEndpoint.java:320）
```java
Long conversationId = Long.valueOf(messageData.get("sessionId").toString());
//                                      ^^^^^^^^^ 期望sessionId字段
String messageType = (String) messageData.get("type");
String content = (String) messageData.get("content");
```

#### 前端需要发送的格式
```javascript
// WebSocket消息格式（嵌套结构）
{
  type: "message",
  payload: {
    sessionId: xxx,      // 必须使用sessionId（后端期望）
    type: 'text',
    content: 'xxx',
    replyToMessageId: xxx,
    clientMsgId: 'xxx'
  }
}
```

#### 建议
有两种解决方案：

**方案1**: 修改后端同时支持 `sessionId` 和 `conversationId`
```java
// ImWebSocketEndpoint.java:320
Long conversationId;
if (messageData.containsKey("conversationId")) {
    conversationId = Long.valueOf(messageData.get("conversationId").toString());
} else if (messageData.containsKey("sessionId")) {
    conversationId = Long.valueOf(messageData.get("sessionId").toString());
} else {
    throw new IllegalArgumentException("conversationId或sessionId不能为空");
}
```

**方案2**: 前端WebSocket发送时使用 `sessionId` 字段名
```javascript
// 前端WebSocket发送格式
wsSendMessage({
  type: 'message',
  payload: {
    sessionId: currentConversationId.value,  // 必须用sessionId
    type: 'text',
    content: inputMessage.value,
    replyToMessageId: replyingMessage.value?.id,
    clientMsgId: clientMsgId,
  }
})
```

#### 相关代码位置
- 后端: `ImWebSocketEndpoint.java` 第315-351行
- 前端: 需要检查 `composables/useImWebSocket.js` 或 `utils/websocket/imWebSocket.js`

---

### 2.3 消息列表分页未正确实现 ⚠️ 性能问题

#### 问题描述
后端 `getMessages` 方法接收了 `lastId` 和 `limit` 参数，但实际查询并未使用这些参数进行分页。

#### 后端代码（ImMessageServiceImpl.java:121-154）
```java
@Override
public List<ImMessageVO> getMessages(Long conversationId, Long userId, Long lastId, Integer limit) {
    List<ImMessageVO> voList = new ArrayList<>();

    ImMessage query = new ImMessage();
    query.setConversationId(conversationId);

    // ❌ 这里没有使用 lastId 和 limit 参数进行分页
    List<ImMessage> messageList = imMessageMapper.selectImMessageList(query);

    for (ImMessage message : messageList) {
        // ... 构建VO
    }

    return voList;
}
```

#### 问题影响
- 会话消息多时返回全部数据，性能差
- 无法实现"加载更多"功能
- 前端传递的 `lastId` 和 `pageSize` 参数无效

#### 建议修复
```java
@Override
public List<ImMessageVO> getMessages(Long conversationId, Long userId, Long lastId, Integer limit) {
    List<ImMessageVO> voList = new ArrayList<>();

    // ✅ 使用分页参数
    Page<ImMessage> page = new Page<>(1, limit != null ? limit : 20);

    LambdaQueryWrapper<ImMessage> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(ImMessage::getConversationId, conversationId);

    // 如果指定了lastId，只查询ID小于lastId的消息（向上翻页）
    if (lastId != null && lastId > 0) {
        wrapper.lt(ImMessage::getId, lastId);
    }

    wrapper.orderByDesc(ImMessage::getId);

    Page<ImMessage> messagePage = imMessageMapper.selectPage(page, wrapper);
    List<ImMessage> messageList = messagePage.getRecords();

    for (ImMessage message : messageList) {
        // ... 构建VO（保持原有逻辑）
    }

    return voList;
}
```

---

### 2.4 getMessages消息类型字段不一致 ⚠️ 潜在Bug

#### 问题描述
`buildQuotedMessage` 方法中使用了错误的字段名 `type`，应该使用 `messageType`。

#### 问题代码（ImMessageServiceImpl.java:187）
```java
// ❌ 错误：使用 type（非数据库字段）
String messageType = originalMessage.getType();
if ("IMAGE".equalsIgnoreCase(messageType) || "FILE".equalsIgnoreCase(messageType)
        || "VIDEO".equalsIgnoreCase(messageType) || "VOICE".equalsIgnoreCase(messageType)) {
    // ...
}
```

#### 建议修复
```java
// ✅ 正确：使用 messageType（数据库字段）
String messageType = originalMessage.getMessageType();
if ("IMAGE".equalsIgnoreCase(messageType) || "FILE".equalsIgnoreCase(messageType)
        || "VIDEO".equalsIgnoreCase(messageType) || "VOICE".equalsIgnoreCase(messageType)) {
    // ...
}
```

---

### 2.5 消息已读状态未自动触发

#### 问题描述
前端有 `markMessageRead` API，但切换会话时未自动调用。

#### 相关代码
```javascript
// api/im/message.js 第58-67行
export function markMessageRead(conversationId, messageIds) {
  return request({
    url: '/api/im/message/read',
    method: 'put',
    data: {
      conversationId,
      messageIds: Array.isArray(messageIds) ? messageIds : [messageIds],
    },
  })
}
```

#### 建议修复
在切换会话时自动标记已读：

```javascript
// store/modules/im.js switchSession action
async switchSession({ commit, dispatch }, session) {
  // 标记当前会话为已读
  if (state.currentSession && state.currentSession.id !== session.id) {
    await markMessageRead(state.currentSession.id)
  }

  commit('SET_CURRENT_SESSION', session)
  commit('CLEAR_SESSION_UNREAD', session.id)

  // 调用后端API标记已读
  try {
    await markMessageRead(session.id)
  } catch (error) {
    console.error('标记已读失败:', error)
  }

  await dispatch('loadMessages', { sessionId: session.id, page: 1, pageSize: 20 })
}
```

---

### 2.5 消息撤回API路径问题

#### 当前状态
- 前端: `DELETE /api/im/message/{messageId}/recall`
- 后端: `DELETE /api/im/message/{messageId}/recall` ✅ 匹配

#### 无需修改

---

### 2.6 会话置顶/静音参数类型问题

#### 问题描述
前端传递 `boolean` 类型，后端期望 `Integer` 类型（0或1）。

#### 前端代码
```javascript
// api/im/session.js 第59-64行
return request({
  url: `/api/im/session/${sessionId}/pin`,
  method: 'put',
  params: { pinned: data.pinned ? 1 : 0 },  // 已转换
})
```

#### 后端代码
```java
// ImSessionController.java 第138-147行
@PutMapping("/{id}/pin")
public Result<Void> togglePin(@PathVariable Long id,
                             @RequestParam Integer pinned,  // 期望Integer
                             ...) {
    ...
}
```

#### 当前状态 ✅
前端已正确转换 `boolean` → `0/1`，无需修改。

---

### 2.7 Store中未引入 markMessageRead API

#### 问题描述
`store/modules/im.js` 中有 `markMessageRead` 相关逻辑，但未导入API函数。

#### 建议修复
```javascript
// store/modules/im.js 顶部添加
import {
  sendMessage as apiSendMessage,
  listMessage,
  recallMessage as apiRecallMessage,
  forwardMessage as apiForwardMessage,
  searchMessages as apiSearchMessages,
  markMessageRead,  // 添加这行
} from '@/api/im/message'
```

---

## 三、后端业务逻辑问题

### 3.1 用户ID获取方式

#### 问题描述
所有Controller都使用 `@RequestHeader(value = "userId", required = false)` 并设置硬编码默认值。

#### 问题代码
```java
@RequestHeader(value = "userId", required = false) Long userId) {
    if (userId == null) {
        userId = 1L;  // 硬编码默认值
    }
}
```

#### 建议修复
1. 实现JWT拦截器从Token中解析用户ID
2. 创建 `@CurrentUserId` 注解简化代码
3. 移除硬编码的默认值

---

### 3.2 WebSocket消息推送可能有问题

#### 需要检查的文件
- `ImWebSocketEndpoint.java` - WebSocket端点
- `ImMessagePushServiceImpl.java` - 消息推送服务

#### 建议验证
1. WebSocket连接建立流程
2. 消息接收和发送格式
3. 消息广播机制
4. 错误处理

---

## 四、修复优先级

| 优先级 | 问题 | 影响 |
|--------|------|------|
| **P0** | 统一变量命名（sessionId vs conversationId） | 核心功能 |
| **P0** | WebSocket消息格式统一 | 实时消息 |
| **P1** | 切换会话时自动标记已读 | 用户体验 |
| **P1** | 消息列表分页正确实现 | 性能 |
| **P2** | 用户ID获取方式优化 | 代码质量 |

---

## 五、具体修复代码

### 5.1 修复 Store 中的变量命名

```javascript
// store/modules/im.js

// 修改 state
const state = {
  currentConversation: null,  // currentSession -> currentConversation
  conversations: [],           // sessions -> conversations
  messageList: loadMessageCache(),
  unreadCount: 0,
  // ...
}

// 修改 actions
async loadMessages({ commit }, { conversationId, page = 1, pageSize = 20 }) {
  const response = await listMessage({ conversationId, page, pageSize })
  // ...
}

async sendMessage({ commit }, { conversationId, type, content, replyTo }) {
  // 直接使用 conversationId，无需映射
  const response = await apiSendMessage({
    conversationId,
    type,
    content: typeof content === 'object' ? JSON.stringify(content) : content,
    replyToMessageId: replyTo,
    clientMsgId,
  })
  // ...
}
```

### 5.2 修复 WebSocket 消息格式

```javascript
// utils/websocket/imWebSocket.js 或 composables/useImWebSocket.js

// 修改发送格式
sendMessage(message) {
  return this.send({
    type: 'chat',
    conversationId: message.conversationId,  // 使用conversationId
    messageType: message.type,
    content: message.content,
    replyToMessageId: message.replyToMessageId,
    clientMsgId: message.clientMsgId,
  })
}
```

### 5.3 添加自动标记已读

```javascript
// store/modules/im.js

async switchSession({ commit, dispatch, state }, conversation) {
  // 标记上一个会话为已读
  if (state.currentConversation && state.currentConversation.id !== conversation.id) {
    try {
      await markMessageRead(state.currentConversation.id)
    } catch (error) {
      console.error('标记已读失败:', error)
    }
  }

  commit('SET_CURRENT_CONVERSATION', conversation)
  commit('CLEAR_CONVERSATION_UNREAD', conversation.id)

  // 调用后端API标记已读
  try {
    await markMessageRead(conversation.id)
  } catch (error) {
    console.error('标记已读失败:', error)
  }

  await dispatch('loadMessages', { conversationId: conversation.id, page: 1, pageSize: 20 })
}
```

---

## 六、测试建议

修复后需要测试以下场景：

1. **消息发送**
   - 单聊消息发送
   - 群聊消息发送
   - 回复消息
   - 转发消息

2. **消息接收**
   - WebSocket实时接收
   - 离线消息重发
   - 消息去重

3. **会话管理**
   - 会话列表加载
   - 切换会话
   - 标记已读
   - 置顶/取消置顶
   - 静音/取消静音

4. **消息操作**
   - 撤回消息
   - 删除消息
   - 搜索消息

5. **分页加载**
   - 首次加载
   - 上拉加载更多

---

## 七、需要进一步验证的问题

以下问题需要运行项目后进一步验证：

1. WebSocket连接地址是否正确配置
2. JWT Token是否正确传递
3. 文件上传/下载是否正常
4. 消息已读回执是否正确显示
5. 未读消息计数是否准确

---

**文档版本**: v1.0
**最后更新**: 2026-01-09
