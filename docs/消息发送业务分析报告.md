# 消息发送业务分析报告

**版本**: 1.0  
**日期**: 2026-02-01  
**范围**: 聊天功能中的消息发送链路（前端 → 接口/WebSocket → 后端服务 → 推送）

---

## 1. 概述

本报告对项目内「聊天 → 发消息」整条发送链路做了梳理与检查，包括：前端入口、Vuex 发送逻辑、HTTP/WebSocket 通道、后端落库与幂等、会话内广播等，并给出可改进点与修复建议。

---

## 2. 消息发送整体流程

### 2.1 流程概览

```
用户输入 → 前端乐观更新(临时消息) → 发送请求(HTTP 或 WebSocket)
    → 后端幂等校验(clientMsgId) → 落库 + 更新会话
    → 广播给会话成员(WebSocket) → 前端收到结果/ACK → 更新为正式消息或失败
```

- **前端**：`ChatPanel.vue` / `useChatPanel.js` 触发发送；统一通过 Vuex `im/message/sendMessage`。
- **请求通道**：当前以 **HTTP POST `/api/im/message/send`** 为主；WebSocket 侧有 `handleChatMessage` 可收消息并调同一套发送服务。
- **后端**：`ImMessageServiceImpl.sendMessage` 负责幂等、落库、未读、@、广播；`ImWebSocketBroadcastServiceImpl.broadcastMessageToConversation` 负责推给会话内其他人。

### 2.2 涉及文件一览

| 层级 | 文件 | 职责 |
|------|------|------|
| 前端 API | `ruoyi-im-web/src/api/im/message.js` | `sendMessage(data)` 调 POST `/api/im/message/send` |
| 前端状态 | `ruoyi-im-web/src/store/modules/im-message.js` | 发送队列、乐观更新、`sendMessage` Action |
| 前端 UI | `ruoyi-im-web/src/views/ChatPanel.vue` | `handleSend`：队列检查、临时消息、调 store、成功/失败更新 |
| WebSocket | `ruoyi-im-api/.../ImWebSocketEndpoint.java` | `handleChatMessage`：解析 payload、调 sendMessage、ACK/错误回包 |
| 发送服务 | `ruoyi-im-api/.../ImMessageServiceImpl.java` | 幂等、落库、未读、@、事件、广播 |
| 广播 | `ruoyi-im-api/.../ImWebSocketBroadcastServiceImpl.java` | 按会话成员 WebSocket 推送 |
| 推送封装 | `ruoyi-im-api/.../ImMessagePushServiceImpl.java` | 离线/在线封装（当前发送主链路未直接走此处） |

---

## 3. 前端发送逻辑

### 3.1 入口与队列控制

- **ChatPanel.vue `handleSend`**  
  - 先查 `store.getters['imMessage/sendingQueueSize']`，若 ≥ 100 直接提示「发送队列已满」并 return，避免继续加临时消息。  
  - 用 `temp-${Date.now()}` 作为临时 id/clientMsgId，插入 `messages`，状态 `sending`，再 `store.dispatch('im/message/sendMessage', { sessionId, type, content, replyToMessageId })`。

- **Store `sendMessage`**  
  - 再次校验 `state.sendingMessages.size >= SENDING_QUEUE_CONFIG.MAX_QUEUE_SIZE`（100），超则 throw，与前端双重保护。  
  - 生成 `clientMsgId = generateUUID()`，把临时消息放入 `sendingMessages` 和当前会话的 `messages`，再调 `apiSendMessage`。

### 3.2 请求体与接口

- **API**：`sendMessage({ conversationId, type, content, replyToMessageId, clientMsgId })`，对应后端 `ImMessageSendRequest`。  
- **Store 里** 用 `sessionId` 传参，在调用 API 时映射为 `conversationId`，前后端字段一致。

### 3.3 成功与失败

- **成功**：`res.code === 200 && res.data` 时，`REMOVE_SENDING_MESSAGE(clientMsgId)`，并用服务端返回的 message 更新对应会话中的那条（按 clientMsgId 对应临时消息替换为正式 id 等）。  
- **失败**：catch 或非 200 时，同样 `REMOVE_SENDING_MESSAGE`，并把该条消息标记为失败（如 `sendStatus: FAILED`），便于重试或提示。

### 3.4 小结（前端）

- 队列限制、乐观更新、clientMsgId 与后端一致，逻辑完整。  
- 唯一建议：`ChatPanel.vue` 里 `maxSize = 100` 与 store 的 `SENDING_QUEUE_CONFIG.MAX_QUEUE_SIZE` 建议抽成同一常量或从 store 读取，避免两处数字不同步。

---

## 4. 后端发送逻辑

### 4.1 入口与幂等

- **HTTP**：`ImMessageController` 的发送接口最终调用 `ImMessageService.sendMessage(request, userId)`。  
- **WebSocket**：`ImWebSocketEndpoint.handleChatMessage` 从 payload 里取 `conversationId/sessionId`、`messageType/type`、`content`、`replyToMessageId`、`clientMsgId`，组 `ImMessageSendRequest`，再调同一 `sendMessage(request, userId)`。

幂等在 **ImMessageServiceImpl.sendMessage**：

- 若 `clientMsgId` 非空，先 `redisUtil.checkAndRecordClientMsgId(clientMsgId)`：  
  - 若已存在则直接查库返回已有消息 VO，不再落库，实现「同一 clientMsgId 只落一次」。

### 4.2 落库与后续步骤

在 **doSendMessage** 中顺序为：

1. **createAndSaveMessage**：写入 `im_message`（内容加密、XSS 转义、clientMsgId、sendStatus 等）。  
2. **recordClientMsgId**：把 clientMsgId → messageId 写入 Redis，供后续幂等。  
3. **updateConversationLastMessage**：更新会话最后一条消息。  
4. **handleUnreadCount**：对会话内其他成员增加未读数。  
5. **processMentions**：@ 提及。  
6. **AuditLogUtil**、**publishGroupMessageEvent**（机器人等）。  
7. **broadcastService.broadcastMessageToConversation(conversationId, message.getId(), sender)**：推给会话内其他成员。

整体事务与分布式锁（按会话维度）使用合理，无重复落库风险。

### 4.3 WebSocket 侧 ACK/错误

- 成功：`sendAckMessage(senderSession, clientMsgId, messageId)`，类型 `message_ack`。  
- 失败：`sendErrorMessage(..., clientMsgId, code, message)`，类型 `message_error`。  
- 若前端将来改为「仅通过 WebSocket 发消息」，可依赖这两类包做发送结果状态更新。

---

## 5. 广播与推送

- **ImMessageServiceImpl** 在发送成功后调用 **ImWebSocketBroadcastService.broadcastMessageToConversation(conversationId, messageId, sender)**。  
- **ImWebSocketBroadcastServiceImpl**：  
  - 按 `conversationId` 查会话成员；  
  - 查 `ImMessage` 并组装 `{ type: 'message', data: ... }`；  
  - 通过 `ImWebSocketEndpoint.getOnlineUsers()` 拿到在线 Session，对除发送者外的成员逐个 `sendText(messageJson)`。

离线用户不在此处处理；若需离线存储，需在推送层或单独服务中接离线消息逻辑（与当前发送主链路分离）。

---

## 6. 已发现的问题与建议

### 6.1 前端

| 项 | 说明 | 建议 |
|----|------|------|
| 队列上限常量 | ChatPanel 里写死 100，与 store 的 MAX_QUEUE_SIZE 可能不一致 | 从 store 的 getter 或统一常量读取 |
| 临时 id | 使用 `temp-${Date.now()}`，高并发下可能同毫秒两条 | 可改为 `temp-${Date.now()}-${Math.random().toString(36).slice(2, 9)}` 或使用与 store 一致的 UUID |

### 6.2 后端

| 项 | 说明 | 建议 |
|----|------|------|
| WebSocket 与 HTTP 双通道 | 发送既有 HTTP 也有 WebSocket，两端都调同一 sendMessage，逻辑一致，无冲突 | 若后续全面切到 WebSocket 发送，可保留 HTTP 作管理/兼容或降级 |
| 广播异常 | broadcastMessageToConversation 内异常已 catch 并打日志，不影响落库 | 可考虑对单用户发送失败做重试或离线补偿（按产品需求） |

### 6.3 一致性

- **clientMsgId**：前端 store 用 UUID，ChatPanel 临时消息用 tempId；发到后端时以 store 传的 clientMsgId 为准，幂等与 ACK 都依赖该字段，当前设计正确。  
- **会话 ID**：前端用 `sessionId`（即 conversationId），后端统一用 `conversationId`，映射正确。

---

## 7. 总结

- **发送链路**：前端乐观更新 → HTTP（或 WebSocket）→ 后端幂等 + 落库 + 未读/@/事件 → 广播到会话成员，流程完整、职责清晰。  
- **发送业务**在幂等、队列限制、错误与 ACK 方面实现到位；仅建议做少量前端常量/临时 id 的小优化，以及按需考虑广播失败时的重试或离线策略。  
- 若要与《消息功能逻辑分析报告》中的「全双工」建议对齐，可在前端增加「优先通过 WebSocket 发消息、收 message_ack/message_error」的路径，后端现有 WebSocket 处理已支持，无需改发送核心逻辑。
